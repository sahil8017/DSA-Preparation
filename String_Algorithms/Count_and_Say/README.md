# ğŸ” The "Count and Say" Problem: A Deep Dive

Welcome to the repository! This project explores the classic **"Count and Say"** problem â€” a fascinating exercise in string construction and pattern recognition. Multiple solutions are implemented in C++ with a focus on iterative and recursive techniques.

---

## ğŸ¯ Problem Statement

The **"Count and Say"** sequence is a series of digit strings defined by the following rules:

- Start with `"1"`.
- Each subsequent term is generated by **reading the previous term**, counting the number of digits in groups of the same digit.

Given a positive integer `n`, return the `n`-th term of the count-and-say sequence.

### Constraints:
- `1 <= n <= 30`

### Example:
- **Input:**  
  `n = 4`  
- **Output:**  
  `"1211"`

**Explanation:**
- term 1: `"1"`  
- term 2: `"11"` â†’ one 1  
- term 3: `"21"` â†’ two 1s  
- term 4: `"1211"` â†’ one 2, then one 1

---

## ğŸ› ï¸ Approaches & Solutions

### 1. Iterative Construction â€“ Efficient & Intuitive

Build the sequence step-by-step using a loop, starting from `"1"` and generating each term by reading the previous one.

**Algorithm:**
- Initialize `result = "1"`.
- Loop `n - 1` times:
  - For each term, iterate through the string and count consecutive digits.
  - Append the count and digit to a temporary string.
- Return the final string after `n` iterations.

**Time Complexity:** O(n Ã— k), where `k` is the average length of the string  
**Space Complexity:** O(k)

ğŸ”— Code: [`Iterative_CountAndSay.cpp`](./Iterative_CountAndSay.cpp)

---

### 2. Recursive Approach â€“ Clean & Elegant

A straightforward recursive solution based on the definition of the problem.

**Algorithm:**
- Base case: if `n == 1`, return `"1"`.
- Recursive step: call the function for `n - 1`, then process the string to build the `n`-th term.

> âš ï¸ May not be optimal for large `n` due to function call overhead.

**Time Complexity:** O(n Ã— k)  
**Space Complexity:** O(n + k)

ğŸ”— Code: [`Recursive_CountAndSay.cpp`](./Recursive_CountAndSay.cpp)

---

## ğŸ§ª Edge Cases to Consider

- Smallest input (`n = 1`)
- Handling of multi-digit counts (e.g., when a term contains more than 9 identical digits)
- Performance for larger values of `n` (e.g., `n = 25` or `n = 30`)

---

## ğŸ“š Additional Resources

- [LeetCode: Count and Say](https://leetcode.com/problems/count-and-say/)
- [GeeksforGeeks: Count and Say Problem](https://www.geeksforgeeks.org/count-and-say/)
- [Understanding Recursion in String Problems](https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do)

